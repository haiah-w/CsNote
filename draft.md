阻塞IO：
- read、write是阻塞的，单个线程在执行时，无法得知是否可读，什么时候可读了，因此只能阻塞等待
- 好处是：阻塞状态下，释放CPU；
- 阻塞时，想要处理别的事件，只能选择开启多个线程，单并不是一个好的选择，Linux下线程相当于一个进程，线程的创建、切换开销比较大，创建更多线程的目的，应该是更有效的利用多核优势，
而非明明有空闲线程，不使用而创建线程；异步IO就是一个更好的选择；

但是异步IO也不是适用于所有场景，事件的轮询接口阻塞是必要的，因为总要第一时间响应到来的事件，且阻塞过程不占用CPU。
如果一个需要不断监听的接口，使用异步IO，事件总不会一直有，线程需要不停地轮询接口，检查是否有事件到来，占有CPU，做着无用功，不如阻塞；

IO多路复用就以此为前提，进行设计：
引入异步IO后，单核前提下，单个线程完全可以处理所有事件的独写，且效率很高，CPU完全处于非空闲状态，除非没有事件；
- 在读写未就绪时，即可返回，监听下一个事件；
```java
while(channel=Selector.select()){   // 阻塞
    if(channel.event==accept){
        // accept
    }
    if(channel.event==write){
        // write 非阻塞
    }
    if(channel.event==read){
        // read 非阻塞
    }
}
```
这就是最简单的Reactor模型了。

1、随着硬件设备的升级，多核CPU普及，IO模型也应该与时俱进，更好的利用多核优势；
2、服务端和客户端目标不同，IO模型也有差异；



HTTP断点续传
多线程下载文件
