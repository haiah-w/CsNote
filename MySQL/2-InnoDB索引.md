# InnoDB索引

- 哈希
- B+树

索引是一种排好序的快速查找的数据结构；

索引优势：

1. 将随机I/O变为顺序I/O，提高数据检索效率,降低磁盘IO成本；
2. 可以通过索引，对数据进行排序，降低了排序的成本；
3. 降低CPU的消耗；
4. 对于字典索引，一对一，很快；

索引劣势：

1. 索引是要占用空间的；
2. 提高查询速度的同时，降低了更新表的速度（INSERT，UPDATE，DELETE）因为数据修改，索引要动态维护；
3. 无法范围查找；

## 哈希索引

基于哈希表的实现，只能精确匹配索引所有列的查询才能生效；

### 原理

对每一行元素，计算出其所有的索引的一个哈希值，存在一张哈希表中；

在查询的时候，根据查询语句中使用的索引，计算出一个哈希值，找到哈希表中的这个值，通过指针，就找到了那行数据；

### 弊端

- 必须全索引列查询；因为哈希表的建立就是全索引；
- 无法范围查询，只能等值查询，精确匹配到；
- 无法进行排序；
- 大量重复字段的话，存在哈希冲突；（拉链法解决）

### 自适应哈希索引

Innodb引擎下，发现有一些索引使用频繁，并且适合于创建哈希索引，他会自行在内存中，基于B+树之上，再创建哈希索引；

这是一个内部的自发行为；

## B+树索引

详细：[【原创】MySQL(Innodb)索引的原理 - 孤独烟 - 博客园](https://www.cnblogs.com/rjzheng/p/9915754.html)

- 有几个索引，就有几颗b+树

- 聚簇索引的叶子节点为磁盘上的真实数据。

- 非聚簇索引的叶子节点只包含索引列和主键；
  
  如果查询存在name字段的索引，通过name索引（非聚簇索引），只能查询出name字段，需要别的字段，需要拿到name字段的主键id，再到聚族索引（主键索引）下查询所有数据；

### 特性

- 非叶子节点不存储data，只存储索引，这样就可以放更多的索引；

- 每一个节点就是1页内存，不存储data信息可以使得查询范围更大；

- 叶子节点用通过双向链表维护数据；

- 粗略算一下：一个高度为3的B+树可以存放记录数：1170×1170×16=21,902,400条记录
  
  假设主键ID一个是：8bit，指针占用6bit，一个索引：14bit，一条记录是1k；
  
  根节点就可以有16x1024➗14 = 1170个索引；
  
  第二层：1170x1170
  
  第三层：1170x1170x16 = 21902400

### 为什么不用二叉树

1. 磁盘预读
   
   B+树每个节点可以存储多个关键字，节点的大小就是磁盘页的大小，磁盘预读的大小为1页（InnoDB的磁盘预读是16k），B+树的一个节点就设置为1页，**充分利用了磁盘预读，尽可能地减少了磁盘IO的次数**；

2. 树深度
   
   B+树每个节点可以存储多个关键字，树的深度就会很小，磁盘IO就更少了；
   
   不存数据的节点，是在内存中，B+树的查询主要在内存中；

### B+树索引类型

- 主键索引（一张表只有一个主键索引）
  
  是根据每张表的主键建造的一棵B+ 树，**叶子节点中存放的是整张表的行记录**。
  
  一张表只能有一个聚集索引。因为聚集索引在逻辑上是连续的，所以它对于主键的排序查找和范围查找速度非常快。
  
  聚簇索引一定是覆盖索引，因为已经包含了所有数据！
  
  - 如果设置主键，即主键为聚簇索引；
  - 如果没有定义，则第一个非空索引，设为聚簇索引；
  - 如果没有索引，InnoDB会创建一个隐藏的row-id为聚簇索引；

- 唯一索引（一张表可以有多个唯一索引）
  
  根据唯一字段创建的索引（唯一字段不可重复）
  
  主键就是唯一的，主键索引就是唯一索引；
  
  但是唯一索引使用的列，可以不是主键；

- 辅助索引
  
  辅助索引不是唯一的，它的**叶子节点只包含行记录的部分数据**以及对应聚集索引的节点位置；通过辅助索引来查找数据时，先遍历辅助索引找到对应主键索引，再通过主键索引查找对应记录。
  
  也就是说：以`name`做索引，会创建一个B+树，比如执行下面查询：
  
  ```sql
  select * from table where name = 'Leo';
  ```
  
  那么会先通过`name`索引的B+树查询到'Leo'所在行数据的主键；
  
  再通过此主键，去主键B+树下查询到所有数据！
  
  但是：如果执行
  
  ```sql
  select name from table where name = 'Leo';
  ```
  
  那么就只用查询一个B+树！（也就是实现了覆盖索引）

- 联合索引
  
  索引通过多个列建立的；查询条件指定多个列，比较常用，但要注意**最左原则**；
  
  最左原则：
  
  idx_a_b_c：此索引支持(a),(a,b),(a,b,c)三种组合的查找，不支持(b,c)查找，所以最常用列要放在最左侧；
  
  所以：
  
  - **应该把最最常用的列，放在最左侧；**

- 覆盖索引（并非索引）
  
  不是一种实际索引，如果查询到的索引中就包含结果集，就是用到了覆盖索引；大大减少了IO；
  
  **也就是只需要在一个B+树上就可以拿到所有数据！**

### 回表

要查询的字段，通过一次索引（此索引的叶子节点数据，包含了要查询的列），就不会回表，经历一次B+树的查询，就可以拿到数据；

```sql
select * from user where username = 'zs';
```

这种情况就会回表， 通过username索引，查询到数据所在主键，再通过主键索引，拿到所有数据；就是回表；

### 索引下推

（两个以上的筛选条件，先回表优化成：先筛选，以此减少回表数据）

索引下推是InnoDB的一种索引优化，减少回表的数据量；

```sql
select * from user where name like '李%' and age > 20;
```

此SQL执行的两种情况：

首先返回的数据是 * ，这也是一个非覆盖索引；会发生回表！

1. 首先通过查询到满足`李%`的数据，拿到主键ID，数据回表，查询全量数据，再筛选age>20；
2. 索引下推优化：查询到满足`李%`的数据，首先过滤age>20，拿到ID再回表查询全量数据；

这样回表的数据，就会大量减少，提高性能；

开启索引下推：

```shell
SET optimizer_switch = 'index_condition_pushdown=off';
```

### 索引的创建：

```sql
-- 创建[唯一索引]普通索引
CREATE [UNIQUE] INDEX indexName ON tableName(columnName);
-- 添加索引
ALTER tableName add [UNIQUE] INDEX [indexName] on (columnName);
-- 创建表的时候，指定索引
CREATE TABLE tableName(
    ...
    INDEX indexName (columnName)
);
```

删除索引：

```sql
DROP INDEX [indexName] on tableName;
```

查看索引：

```sql
SHOW INDEX FROM tableName\G;
```

强制索引查询 indexed by

```sql
select * from salaries
indexed by idx_emp_no
where emp_no = '10005'
```

### 创建索引的时机

1. 频繁作为查询条件的字段，应该创建索引；
2. 排序字段，通过索引排序，能大大提高排序速度；
3. 查询中的统计和分组字段

### 不适合创建索引的情况

1. 频繁更新的字段，每次更新，会同时更新记录和索引；
2. 对于小表，全表扫描比建立索引更快，中到大型表，索引非常有效；
3. 类似于性别的字段，男或者女，不要建索引，没有意义；

### 索引失效

索引失效会导致**行锁**变**表锁**；

```sql
-- 索引列：age，并且是varchar类型
set autocommit = 0;
update emp set username = 'king' where age = 24; -- 这里进行了隐式类型转换，导致索引失效
-- 此时通过另一个session来修改此表的另一条记录
-- 这里会被阻塞；因为索引失效已经导致行锁升级为表锁(写锁)
update emp set username = 'kkk' where id = '3';
```

索引失效情况：

1. 复合索引的最左原则
   
   比如索引：idx_a_b_c：
   
   此索引支持(a),(a,b),(a,b,c)三种组合的查找，不支持(b)，(c)，(b,c)查找，所以最常用列要放在最左侧；

2. 对索引列的任何操作（计算，函数，**隐式类型转换**，手动类型转换），都会导致索引失效，而变成全表扫描
   
   ```sql
   -- 全表扫描
   select * from article where id  + 1 = 5
   -- 走索引
   select * from article where id = 4
   -- varchar类型id——隐式类型转换，全表扫描
   select * from article where id = 100
   -- 走索引
   select * from article where id = '100'
   -- 使用函数，索引失效
   select * from article left(name, 4) = 'Tile'
   ```

3. 使用`!=`、`<>`不等于的时候，索引失效，导致全表扫描

4. `is null`，`is not null`无法使用索引

5. 通配符开头的模糊查询，使索引失效
   
   ```sql
   -- 全表扫描
   select * from article where author like '%李'
   -- 走索引
   select * from article where author like '李%'
   -- 走索引
   select * from article where author like 'k%kk%'
   ```
   
   解决办法：
   
   （1）加入虚拟列；
   
   name_reverse（MySQL5.7以后自带的）
   
   要查询李开头的名字，通过反转查询
   
   ```sql
   -- 走索引
   select * from article where author_reverse like '李%'
   ```
   
   （2）使用覆盖索引：
   
   ```sql
   -- 已经建立了username的索引
   explain select username from emp where username like '%li%';
   +------+-------------+-------+-------+---------------+
   | id  | type  | possible_keys | ref  | rows | Extra             
   +------+-------------+-------+-------+---------------+
   |   1 | index | NULL          | NULL |   6  | Using where; Using index 
   +------+-------------+-------+-------+---------------+
   ```

6. or连接，索引失效
