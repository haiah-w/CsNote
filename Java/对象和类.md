# 对象创建的过程

### 1.类加载检查

虚拟机遇到一条 new 指令时，会检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

### 2.分配内存

在类加载检查通过后，接下来虚拟机在Heap区域将为新生对象分配内存。

两种分配方式：（**使用哪种方式取决于堆内存是否规整，而堆内存是否规整则由使用的垃圾收集算法决定**）

- 指针碰撞：（堆内存规整的方法）
  
  **在连续剩余空间中分配内存**。用一个指针指向内存已用区和空闲区的分界点，需要分配新的内存时候，只需要将指针向空闲区移动相应的距离即可。

- 空闲列表：（堆内存不规整的方法）
  
  **在不规整的剩余空间中分配内存**。如果剩余内存是不规整的，就需要用一个列表记录下哪些内存块是可用的，当需要分配内存的时候就需要在这个列表中查找，找到一个足够大的空间进行分配，然后在更新这个列表。

### 3.设置初始值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值

### 4.设置对象头

初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。

这些信息存放在对象头中。 

### 5.执行init方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始。

继续执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

# 对象头

参考下面链接。很详细

https://blog.csdn.net/smileiam/article/details/80364641

HotSpot虚拟机的对象的内存分布主要分为三个部分：

- 对象头（分为两部分）
  
  1. 第一部分用于存储对象自身的运行时数据，如哈希吗，GC分代年龄（又称为Mark Word）
  2. 第二部分用于存储指向方法区对象类型数据的指针。即是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。

- 实例数据（真正存储有效信息）

- 对齐填充（非必须，仅起着占位符的作用）
  
  HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，即对象大小必须是8字节的整数倍。而对象头正好是8字节的整数倍，而对象实例数据部分没有对齐，需要通过对齐填充来补全。

虚拟机通过Mark Word的信息来区分锁的状态：

![duoxian](../.images/suo.png)

Epoch：偏向时间戳

# 对象是否已死？

要进行垃圾收集，首先需要判断对象是否已经没用，才能进行收集。

在主流的程序语言（Java、C#）中，都是使用**可达性分析算法**来判断对象是否存活，还有一种叫做**引用计数算法**，但是Java没有使用它。

### 一、引用计数算法

一个对象，增加一个引用，就增加一个计数，删除一个引用，就减少一个计数。

此算法效率高，实现简单。

垃圾回收时，只用收集计数为0的对象。此算法最致命的是**无法处理循环引用**的问题。

循环引用：

现在有两个对象objA、objB；都有字段instance，且objA.instance=objB，objB.instance=objA

这样两个对象：objA、objB，互相引用对方的实例，则无法使用此算法进行回收。

### 二、可达性分析算法

基本思路：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径成为引用链，如果没有引用链到达GC Roots对象，那么就被认为是可以回收的对象。

在Java语言中，可以作为GC Roots的对象的有下面几种：

- 元空间的Class对象
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；

即使对象不可达，也不是立即回收；

对象会被执行`finalize()`方法，之后被放入一个队列，触发一个低优先级的线程去执行最终的回收；

# 类加载机制

类的生命周期：

类加载分为三个部分：加载，连接，初始化；

### 1. 加载

完成三件事：

- 通过一个类的全类名来获取定义此类的二进制字节流
- 根据字节码文件，加载静态数据到元数据空间；
- 在Heap内存中生成一个代表这个类的java.lang.Class对象，作为元空间这个类的各种数据的访问入口

这个阶段，如果是非数组对象，是可以使用JVM提供的类加载器完成加载，也可以根据自己定义的类加载器完成加载；

但是数组对象，是由Java虚拟机直接创建的，不通过类加载器创建；但是，如果数组的类型，是对象类型，还是要通过类加载器创建的；

### 2. 验证

此阶段只有一个目的：

校验字节码文件的正确性；

确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身；

主要由：

1. 验证`.class`文件格式是否正确；

2. 验证元数据是否正确；比如：有没有父类，与父类是否冲突；是否继承了不允许继承的类；

3. 验证字节码文件：这一步就具体的验证了类的内容是否合适；比如：一些类型转换，是否符合规矩；

4. 符号引用验证：比如：能否通过这个全限定类名的字符串找到这个类；
   
   再比如：这个类的字段的访问性是否合适，就是访问控制关键字；private，public....

### 3. 准备

给**静态变量**分配内存，并设置初始化默认值，并非用户自定义的值；

这些数据，在元数据空间，分配内存；

（仅包括**静态变量**，此时没有对象，实例变量不在这里准备）

### 4. 解析

将**符号引用**替换成**直接引用**；

符号：就是类名，变量名，方法名等等；

就是：

比如main方法，将其替换为一个指向内存地址的指针；

### 5. 初始化

即初始化静态变量；

真正执行Java程序代码的阶段；

根据代码，将用户定义的值，赋值给静态变量；

### 触发初始化的5种情况：

1. 为一个类型创建一个新的对象实例时（比如new、反射、序列化）
2. 读取、设置一个类的静态字段，调用类的静态方法；
3. 使用反射对类进行调用的时候，如果没有进行过初始化，则触发初始化；
4. 初始化一个类，发现其父类还没有初始化，那么会初始化其父类；
5. 虚拟机启动，需要指定主类，那么这个主类，会被首先初始化；

# 双亲委派模型

### 类加载器的种类

- 启动类加载器（Bootstrap ClassLoader）：C++语言实现
  
  加载JAVA_HOME\lib，或者被-Xbootclasspath参数限定的类

- 扩展类加载器（Extension ClassLoader）：
  
  加载\lib\ext，或者被java.ext.dirs系统变量指定的类

- 应用程序类加载器（Application ClassLoader）：
  
  加载ClassPath中的类库

- 自定义类加载器（User ClassLoader）：
  
  加载自己定义的类

### 工作过程

一个类加载器收到类加载的请求，不会自己去尝试加载这个类，而是将这个请求委派给父类加载器去完成；

每一层的类加载器，都是如此，最终家在请求都会传送到顶层的启动类加载器；

只有父类加载器无法完成加载请求（比如Bootstrap ClassLoader只能加载rt.jar），自类加载器才会尝试自己加载；

#### 举个例子：

能不能自己写一个Object类，String类？

不能，Java的String类，在rt.jar中，如果自己写一个String类，任何类加载器都会将加载请求提交给Bootstrap ClassLoader，在同一个加载器中，自己写的类，与Java的String类，出现冲突，无法完成加载；

#### 双亲委派的好处

1. 避免同一个类被多次加载；
2. 使得Java的类随着类加载器一起具备了优先级的层次关系；
3. 保证了Java的类型体系中最基础的行为；如：基础类不得用户定义；

### JDBC如何破坏双亲委派

首先JDBC的核心类，是在rt.jar中的；但是其实现，是mysql-connector-java.jar中；

既然rt.jar的类调用外部jar包，那么，外部jar包也应由Bootstrap ClassLoader来加载，

但是Bootstrap ClassLoader只能加载rt.jar包，无法实现；

所以，引入了线程上下文类加载器（Thread Context ClassLoader）

该类加载器通过Thread类的getContextClassLoader( )获取线程上下文对象来加载Driver（MySQL驱动）实现类；
