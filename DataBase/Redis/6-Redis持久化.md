# Redis持久化

Redis宕机，内存是会清空的；

如果无法及时恢复数据，是容易造成缓存雪崩，关系数据库就会承受大量请求！

Redis需要保证，宕机、重启，仍能快速恢复数据的持久化机制：

- RDB (快照)
- AOF (日志)
- 混合持久化 (4.0后引入)

# RDB快照

将某个时间点的全量数据，写入一个临时dump.rdb快照文件；

两个命令实现：

- SAVE：阻塞Redis服务器进程，直到RDB文件创建完成；
- BGSAVE：fork一个子进程进行创建RDB文件，主进程可以继续响应客户端；

RDB的执行策略：

（1）手动使用命令，创建dump.rdb文件（压缩的二进制文件）

（2）自动定期执行；（save配置）

RDB的载入：

（1）会优先执行AOF的载入，如果没有开启AOF，才会载入RDB文件；

（2）载入过程服务器一直处于阻塞状态；

RDB的配置：

```shell
# (默认配置)
save 900 1 # 900s内，修改了1次，就会执行BGSAVE
save 300 10
save 60 100

# 输出文件
dbfilename dump.rdb
```

特点：

1、只有一个dump.rdb文件。二进制序列，节奏紧凑，文件小；

2、性能好：父进程fork一个子进程来进行写操作，主进程可以继续响应客户端，子进程进行持久化；

3、RDB每隔一定时间进行一次持久化，不保证不会丢数据(持久化间隔间宕机)；

- 时间间隔小，就会引起大量的磁盘IO，影响性能；

- 间隔大，就会存在宕机，丢失数据的风险；

# AOF日志

AOF：将**写命令**以纯文本的方式追加写入日志文件；重启则重放日志的指令，完成数据恢复；

AOF执行流程:

Redis服务器，每执行一个写命令，就追加到缓冲区内；根据`appendonly`策略，追加到aof文件中；

```conf
appendonly [no, everysec, always]
appendfilename "appendonly.aof"
```

- no：不开启；

- everysec：每秒同步；

- always：每次修改同步—修改自动触发同步，安全，效率低；

特点：

1、数据安全，可以每次操作，都同步到aof文件；

2、体积大，文件比较大；数据量大的时候，启动速度比较慢

# 对比

1. RDB文件紧凑，体积小，数据恢复速度快；AOF体积大，数据恢复速度慢；

2. RDB基本不影响Redis的主进程性能；频繁持久化AOF对Redis性能影响较大；

3. 如果发生故障，RDB丢失数据较多，因为快照的间隔时间比较长；
   
   AOF的数据则更完整，触发写日志的时间间隔是秒级；

# 混合持久化

# 集群持久化策略

- Master不要做持久化工作，专注于处理客户端任务；
  
  让某个Slave进行AOF备份数据，策略：每秒同步一次；

- 最好是Master，Slave通过内网链接，速度、稳定性、安全性有保障；
