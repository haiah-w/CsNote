## 全局锁

全局锁就是对整个数据库实例加锁；

场景：

做**全库逻辑备份**，加全局锁，确保整个库只读；

弊端：

- 在主库备份，备份期间不能更新，业务停摆；
- 在从库备份，备份期间，不能执行主库同步来的bin log，主从同步会延迟；

所以常用备份方案：

- 在InnoDB的可重复读的隔离级别下开启事务；使用自带的工具mysqldump进行备份；

## 表级锁

MyISAM引擎使用表级锁，不支持行级锁；

分为：

- 读锁：`LOCK TABLE table_1 read;`

多个会话都可以进行读取；所有会话不可插入，更新；

- 写锁：`LOCK TABLE table_1 write;`

当前会话可以查询，更新，插入；其他会话查询，插入，更新都会阻塞；

解锁都为：`UNLOCK TABLES；`

## 行级锁

InnoDB引擎使用行级锁；

行锁优劣：

- 锁粒度最小了，并发度最高；
- 开销大，加锁慢；

其他会话，无法读取，修改当前行的数据；

## 死锁

这样互相占用资源，并等待对方释放资源，产生死锁；

![](../.images/sisuo.png)

解决方式：

1. 设置超时时间，通过参数`innodb_lock_wait_timeout`（默认50s）来设置，超时自动退出；
   
   这个方式**不可取**，设置的时间，无法确定；
   
   如果设置很短，可能本来不是死锁的会话也被中断执行，就不可取；

2. 设置死锁检测，检测到死锁，自动回滚某一个事务，让其他事务继续执行；参数：`innodb_deadlock_detect设置为on`开启；
   
   一般采取此策略；但是，弊端是：每次会话，都检测死锁，定会**耗费性能**；

## 间隙锁

间隙锁是为了防止幻读；

符合条件，但并不存在的记录，为间隙；

如果范围为1-10，但是并没有第2条记录，在操作的时候，会同时把2给锁住，即无法插入2号记录；

## 悲观锁

在事务中，在不使用update的情况下，使用`for update`来排他锁；

```sql
select username from emp where id =3 for update;
-- 执行完上述语句，就自动锁定此行，直到commit提交完毕，才解锁此行；
```

### 锁表还是锁行？

缩表还是锁行，取决于查询是否使用where，明确了主键，

如果明确，所行，如果没有，就锁表；

## 乐观锁

version版本控制

步骤：

1. 先查询出当前修改的数据的version
   
   ```sql
   select (status,status,version) from t_goods where id=#{id}
   ```

2. 修改数据时，带上version的判断：
   
   ```sql
   update t_goods 
   set status=2,version=version+1
   where id=#{id} and version=#{version};
   ```
