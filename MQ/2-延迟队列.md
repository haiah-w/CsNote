分布式延迟队列：RabbitMQ、RocketMQ、Redis

进程内延迟队列：Java的DelayedWorkQueue

# 延迟队列设计

延迟队列的核心：
- 消息的存储：小顶堆、HashMap
- 消息的获取：
  - 开一个轮询线程，根据要求精度，可以设置轮询的频率(如：500ms轮询一次)
  - 时间轮算法

消息存储设计：
- 小顶堆：以触发时间作为排序条件，获取最新消息的时间复杂度O(nlogn)，因为需要O(nlogn)的时间复杂度进行siftDown维护；
- HashMap：以触发时间作为key，获取最新消息时间复杂度O(1)，不需要再维护，获取后删除key即可；

无论哪一种，元素的value需要设计为链表、列表等，可能多个任务触发时间相同；

消息的获取：

1、轮询：需要一个单独线程，进行轮询，当前时间戳 >= 堆顶元素的触发时间，则取出所有任务，提交线程池；
根据具体场景，可以设置线程的轮询频率；
- 小顶堆，可以直接对比堆顶元素即可；
- HashMap，轮询时间精度要小于任务触发时间的精度(每500ms轮询当前秒的任务)，才能做到O(1)的复杂度，否则要遍历；

2、时间轮算法


# 延迟队列实现

1、Java自带的调度线程池实现了DelayedWorkQueue

2、利用开源MQ：RocketMQ、RabbitMQ、不建议使用kafka(kafka不提供延时功能，需要自行实现)

3、Redis：

- 利用Redis的过期通知，绑定Redis-key过期通知，当key过期，回调通知；
  - 可靠性很低，Redis的key是惰性删除，会有延迟，并且本身没有ACK机制，只会通知一次；
  - 只能拿到Key，拿不到value；
- 利用Redis的zset，开轮询线程；

本身做延迟队列的消息是不紧急，性能要求不高的，使用Redis不是个好策略；
